Method1: sub-sampling frames -- processing every x frame i.e. process frame N and then frame N+x, and for all intermediate frames just use the value obtained for N - total processing time will reduce, but utility might decrease as intermediate frames values might differ from baseline. Parameter for this method is x, how many frames you drop.
Method2: reduce resolution for each frame. Lower resolution frames might be processed faster, but having higher errors. Parameter can be resolution XxY.
Method3: split work spatially across threads (application level pthreads) by giving each thread part of a frame to process. Parameter can be number of splits i.e. number of threads, if each thread gets one split. You might need to take care of boundary pixels that different threads process for utility.
Method4: split work temporally across threads (application level pthreads), by giving consecutive frames to different threads for processing. Parameter can be number of threads.

The folder contains cpp files for implementing each of the methods. For method3 and method4, there are two files each, one containing code for finding queue density and other for finding dynamic density. Makefile can be used for compiling any of these files. All the files can be compiled using the command make all.
Then for running method1, type ./method1 videoname  in the command line. If the video is present in the folder, the code will run otherwise it will throw an error. if the video is present, the code will run and ask for the required parameter, e.g no. of threads in method4. Enter the value, then the code will run and create a file with .txt in the same folder with the output. Runtime will be printed on the command line. This can be done for each of the methods. These .txt files can now be used for finding utility metric and then plotting a graph.
